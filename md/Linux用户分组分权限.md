# Linux用户（组）管理

# 用户（组）篇

## 1.1 超级用户root 与`sudo`

 Linux系统中的root账号通常用于系统的维护和管理，对系统所有资源具有访问权限。**因为权限过大，甚至可以删除系统文件致使系统瘫痪，所以不推荐直接使用root** ,而是使用`home`目录下的个人账号(称为**标准用户**)。

 标准用户有时候必须得到类似root账号的权限才能做一些事情，所以在Linux系统中使用`sudo`可以为了标准用户预设root身份。

```
sudo 命令 　　　# 用预设的root身份来执行命令
```

## 1.2 组和用户的创建与删除 `group`、`user`

```
sudo groupadd [选项] 组名　　　#添加新的组

sudo groupdel [选项] 组名　　　 #删除一个组

sudo useradd [选项] 用户名　　　#创建新用户
```

- `-m` : 自动建立用户家目录，**创建用户时最好加这个** 。
- `-g 组名` : 指定用户所在的组，***否则会建立一个与用户同名的组\*** ， 如： `sudo useradd -m -g 组名 用户名`

```
sudo passwd 用户名　　　# 给用户设置密码，如果是给当前用户设置密码，则不用写用户名
```

*家目录的权限默认为： 用户（rwx）,组和其他（r-x）*

```
gpasswd [选项] 组　　　# 组中添加或删除用户
```

选项：

- `-a 用户名` : 将用户添加到组中
- `-d 用户名` ： 将用户从组中删除

```
sudo userdel [选项] 用户名　　　#删除一个用户
```

## 1.3 查看组、用户的配置信息 `id` 、`who`、`whoami`、 `w`

添加的组会保存到`/etc/group`文件中，可以通过`cat -n /etc/group | grep 组名` 单独查看信息。

创建的用户保存在`/etc/passwd`文件中，可以通过`cat -n /etc/passwd | grep 用户名` 单独查看信息。

***用户配置文件\***

```
$ cat -n /etc/group | grep leomessi   # 查看leomessi组的信息
     69 kmust:x:1001:              # 组id为1001，69为行号

$ cat -n /etc/passwd | grep zyq  # 查看 zyq 用户的信息
    40  zyq:x:1000:1000:zyq,,,:/home/zyq:/bin/bash 
# 40：行号
#zyq：用户名
#x : 密码标志，真正的密码是放在shadow（影子文件）中，并且加密
#1000:1000: 分别是UID和GID。UID（用户ID）: 0（超级用户），1~499(系统用户)，500~65535(普通用户)。 要想修改一个用户为超级用户，只需将UID改为0即可
#zyq,,,  ： 用户的说明信息，当初创建用户时随便写的
#/home/zyq : 家目录 
#/bin/bash : 登录使用的shell(ubuntu是dash软件)
```

## 1.4 切换用户 `su`

```
su - [用户名]　　　# 切换用户，- 表示同时切换到家目录，用户名不写默认切换到root用户
exit 　　　 # 退出当前登录用户到上一个用户
```

## 权限控制 `ACL`

ACL 是访问控制列表，是一种权限分配之外的普遍范式。为了应对复杂多变的权限设置。

ACL 权限是否被支持与系统根目录所在分区有关。（可用df -h 查询根目录所在分区），通过dumpe2fs -h /dev/sda3 #查询指定分区详细文件系统信息 查看字段Default mount options:，出现acl字样说明被支持。在当前绝大多数为文件系统是默认支持ACL权限的，并且在被支持的前提下，ACL是默认已经开启的，如果没有开启，开启方法请自行搜索。

```
setfacl [选项] 文件名　　　#对文件为设置对象设置ACl权限
```

选项：

-m 被设置对象 : 设置ACL权限
-x {u:user|g:group} : 删除指定的ACL权限
-b : 删除所有ACL权限，后不用加被设置对象。 会把用户和组权限都删除
-R : 针对目录递归设置ACL权限， 如setfacl -m u:xiaoting:rx -R ./c
被设置对象：

u:用户名：{r|x|w} ： 指定用户设置权限，如u:zhagnsan:rx 。
g:组名：{r|w|x} : 指定组设置权限
m:{r|w|x} : 指定mask权限（最大权限）

***提示：\*** 添加的ACL权限和mask权限相与得到的权限才是真正能执行的权限，默认情况下mask的权限为`rwx`，可以通过修改mask的权限来控制添加了ACL权限之后的真正最大有效权限 。

某一目录被递归设置权限后，该目录下的所有子目录与子文件都被设置了权限，假如此时在该目录下又新建了新的目录或文件，则该文件或目录是没有权限的，所以，需要设置默认ACL权限 （即设置为默认ACL权限的目录，针对该目录下新添加的子文件或目录都默认继承该目录的权限，以前已经存在的权限并不会变，但目录变了），方法是在被设置对象前加d:。

```
getfacle 文件名　　　# 查看ACL权限
```

***提示：\*** 添加了ACL权限的目录或者文件，用`ls -l`命令后，文件或目录末尾会显示`+`图标。

**ACL演练：**

```
# 对当前目录下的c目录，递归添加ACL权限：用户xiaoting具有rw权限。但是以后目录c下新建的文件或目录并没有该权限。
$setfacl -m u:xiaoting:rw -R c 
# 对当前目录下的c目录，递归的添加ACL权限：用户xiaoting具有rx权限。以后目录c下新建的文件或目录自动对该用户添加该权限 。而目录c下以前就存在的文件的权限依然没有变，但是以前就存在的目录的权限却变化了。原因是-R选项本身就是递归的改变。
$ setfacl -m d:u:xiaoting:rx -R c 
#对当前目录下的c目录,递归的取消所有ACL权限，包含目录c下的所有子文件和子目录
$setfacl -b -R c
```



引用：https://blog.csdn.net/zyqblog/article/details/79226826