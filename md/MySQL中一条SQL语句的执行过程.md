# MySQL中一条SQL语句的执行过程

这是在网上找到的一张流程图，写的比较好，大家可以先看图，然后看详细阅读下面的各个步骤。

![preview](https://pic3.zhimg.com/v2-33018662d8baaa222effc14419fdd74a_r.jpg)

1. ###### 查询语句的执行顺序：

   - 客户端通过TCP连接发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配（max_connections，8小时超时）
   - 建立连接后客户端发送一条语句，mysql收到该语句后，通过命令分发器判断其是否是一条select语句，如果是，在开启查询缓存的情况下，先在查询缓存中查找该SQL是否完全匹配，如果完全匹配，验证当前用户是否具备查询权限，如果权限验证通过，直接返回结果集给客户端，该查询也就完成了。如果不匹配继续向下执行。（注意：此步并不做词法及语法分析，也就是用不到分析器，这块原来我也很疑惑，如果不做分析mysql怎么知道我要查什么？解释如下：{MySQL将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。  当判断缓存是否命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。} 其实说白了大概就是拿着你的SQL和原始缓存的SQL比对）
   - 如果在查询缓存中未匹配成功，则将语句交给分析器作语法分析，MySQL需要知道到底要查哪些东西，如果语法不对，就会返回语法错误中断查询
   - 分析器的工作完成后，将语句传递给预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义等
   - 语句解析完成后，MySQL就知道要查什么了，之后会将语句传递给优化器进行优化（通过索引选择最快的查找方式），并生成执行计划。
   - .之后交给执行器去具体执行该语句，在执行之前，会先检查该用户是否具有查询权限，如果有，继续执行该语句。执行器开始执行后，会逐渐将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。（缓存到查询缓存受到几个参数的影响 1.query_cache_type 是否打开查询缓存,默认为OFF  2.query_cache_size:查询缓存使用的总内存空间,默认值为1M   3.query_cache_limit 对于大于该值的结果集不会被缓存，默认值1M，在8.0版本后该参数被移除了）（如果该SQL执行过程中超过了慢查询阀值，该SQL会被记录到慢查询日志中）

2. ###### 一条更新语句的执行顺序：

   - 客户端通过TCP连接发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配（max_connections，8小时超时）
   - .建立连接后客户端发送一条语句，mysql收到该语句后，通过命令分发器判断其是否是一条更新语句，如果是，则直接发送给分析器做语法分析
   - 分析器阶段，MySQL需要知道到底要查哪些东西，如果语法不对，就会返回语法错误中断查询
   - 分析器的工作完成后，将语句传递给预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义等
   - 语句解析完成后，MySQL就知道要查什么了，之后会将语句传递给优化器进行优化（通过索引选择最快的查找方式），并生成执行计划
   - 执行器根据生成的执行计划去open table，此时会先去查看该表上是否有元数据（MDL）排他锁（如果有元数据共享锁则无影响），如果有元数据排他锁，则事物被阻塞，进入等待状态（时间由lock_wait_timeout决定，默认是一年。。。。），等元数据锁被释放，继续执行。如果无元数据锁或者是有元数据共享锁，则该事务在表上加元数据共享锁（因为元数据共享读锁之间是不冲突的，如果表上有元数据共享锁，我们执行alter table这样的DDL语句时，会进入等待状态，因为DDL语句需要在表上加元数据排他锁）
   - 进入引擎层（默认innodb），去innodb_buffer_pool里面的data dictionary得到表得相关信息
   - 根据表信息去innodb_buffer_pool里面的lock info查看是否有相关的锁信息，如果有则等待（因为要加排它锁），如果没有则加排它锁，更新lock info
   - 取读取相关数据页到innodb_buffer_pool中（如果数据页本身就在缓存中，则不用从硬盘读取）
   - 将页中的原始数据（快照）保存到undo log buffer中（undo log buffer会以相关参数定义的规则进行刷盘操作写入到undo tablespace中）
   - 在innodb_buffer_pool中将相关页面更新，该页变成脏页（脏页会以相关参数定义的规则进行刷盘操作写入所属表空间中）
   - 页面修改完成后，会把修改后的物理页面保存到redo log buffer中，（redo log buffer会以相关参数定义的规则进行刷盘操作写入到redo tablespace中）
   - 如果开启binlog，则更新数据的逻辑语句也会记录在binlog_cache中（binlog会以相关参数定义的规则进行刷盘操作写入到binlog file 中）
   - 如果该表上有二级索引并且本次操作会影响到二级索引，则会把相关的二级索引修改写入到innodb_buffer_pool中的change buffer里（change buffer 会以相关参数定义的规则进行刷盘操作写入所属表空间中）
   - 前期的准备工作到此已经做完了，之后便是事务的commit或者rollback操作。一般情况下执行的是commit操作
   - 执行commit操作后（mysql默认开启自动提交，如果手动开始事务begin，则需要显示提交commit），由于要保证redolog与binlog的一致性，redolog采用2阶段提交方式。
   - 将undo log buffer及redo log buffer刷盘（innodb_flush_log_at_trx_commit=1），并将该事务的redolog标记为prepare状态
   - .将binlog_cache数据刷盘（sync_binlog=1）
   - 如果开启了主从结构，此时会将binlog_cache中的信息通过io线程发送给从机，如果开启了半同步复制则需要等待从机落盘（relay log）并反馈。如果是异步复制则无需等待(默认是异步复制)
   - 待binlog落盘完成，再将redolog中该事务信息标记为commit，释放相关锁资源。此时一个更新事务的操作已经完成，返回给客户端成功更新提示。
   - 标记undolog中该事务修改页的原始快照信息为delete，当无其他事务引用该原始数据时(MVCC)，再将其删除
   - 如果此时触发了脏页刷盘操作，会先将脏页写入到double write buffer中（防止写入过程中出现断页，因为mysql页面默认为16K，linux操作系统最大为4K，如果写了8K时系统挂了，这个数据页将不完整，标记为损坏）然后再写到期所在表空间的相应位置。



![sql](https://i.loli.net/2021/09/09/6jUJwdBvEhKLQ4P.png)

引用：https://blog.csdn.net/finalkof1983/article/details/84450896